import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { insertShiftSchema } from "@shared/schema";
import { randomUUID } from "crypto";

export async function registerRoutes(app: Express): Promise<Server> {
  // Authentication middleware
  const requireAuth = async (req: any, res: any, next: any) => {
    const sessionId = req.headers.authorization?.replace('Bearer ', '');
    if (!sessionId) {
      return res.status(401).json({ message: '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è' });
    }

    const session = await storage.getSession(sessionId);
    if (!session) {
      return res.status(401).json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞—è —Å–µ—Å—Å–∏—è' });
    }

    const employee = await storage.getEmployee(session.employeeId);
    if (!employee) {
      return res.status(401).json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' });
    }

    req.user = employee;
    next();
  };

  // Role-based access control
  const requireRole = (roles: string[]) => {
    return (req: any, res: any, next: any) => {
      if (!req.user || !roles.includes(req.user.role)) {
        return res.status(403).json({ message: '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞' });
      }
      next();
    };
  };

  // Auth routes
  app.post('/api/auth/login', async (req, res) => {
    try {
      const { username, password } = req.body;
      
      if (!username || !password) {
        return res.status(400).json({ message: '–í–≤–µ–¥–∏—Ç–µ –ª–æ–≥–∏–Ω –∏ –ø–∞—Ä–æ–ª—å' });
      }

      const employee = await storage.getEmployeeByUsername(username);
      if (!employee || employee.password !== password) {
        return res.status(401).json({ message: '–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å' });
      }

      const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(); // 24 hours
      const session = await storage.createSession({
        employeeId: employee.id,
        createdAt: new Date().toISOString(),
        expiresAt,
      });

      res.json({
        token: session.id,
        employee: {
          id: employee.id,
          name: employee.name,
          username: employee.username,
          role: employee.role,
          initials: employee.initials,
          color: employee.color,
        },
      });
    } catch (error) {
      res.status(500).json({ message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
    }
  });

  app.post('/api/auth/logout', requireAuth, async (req: any, res) => {
    try {
      const sessionId = req.headers.authorization?.replace('Bearer ', '');
      if (sessionId) {
        await storage.deleteSession(sessionId);
      }
      res.json({ message: '–í—ã—Ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω' });
    } catch (error) {
      res.status(500).json({ message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
    }
  });

  app.get('/api/auth/me', requireAuth, async (req: any, res) => {
    res.json({
      id: req.user.id,
      name: req.user.name,
      username: req.user.username,
      role: req.user.role,
      initials: req.user.initials,
      color: req.user.color,
    });
  });

  // Employee routes
  app.get('/api/employees', requireAuth, async (req, res) => {
    try {
      const employees = await storage.getAllEmployees();
      res.json(employees.map(emp => ({
        id: emp.id,
        name: emp.name,
        username: emp.username,
        role: emp.role,
        initials: emp.initials,
        color: emp.color,
        telegramId: emp.telegramId,
      })));
    } catch (error) {
      res.status(500).json({ message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
    }
  });

  app.patch('/api/employees/:id', requireAuth, requireRole(['admin']), async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { telegramId } = req.body;
      
      const updated = await storage.updateEmployee(id, { telegramId });
      if (!updated) {
        return res.status(404).json({ message: '–°–æ—Ç—Ä—É–¥–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω' });
      }
      
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
    }
  });

  // Shift routes
  app.get('/api/shifts/:year/:month', requireAuth, async (req, res) => {
    try {
      const year = parseInt(req.params.year);
      const month = parseInt(req.params.month);
      
      const shifts = await storage.getShifts(year, month);
      res.json(shifts);
    } catch (error) {
      res.status(500).json({ message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
    }
  });

  app.post('/api/shifts', requireAuth, requireRole(['admin', 'worker']), async (req, res) => {
    try {
      const shiftData = insertShiftSchema.parse(req.body);
      
      // Check if shift already exists
      const existingShift = await storage.getShift(shiftData.date, shiftData.shiftType);
      let shift;
      let isUpdate = false;
      
      if (existingShift) {
        // Update existing shift
        shift = await storage.updateShift(existingShift.id, {
          employeeId: shiftData.employeeId,
        });
        isUpdate = true;
      } else {
        // Create new shift
        shift = await storage.createShift(shiftData);
      }

      // Send Telegram notification
      try {
        const employee = await storage.getEmployee(shiftData.employeeId);
        if (employee?.telegramId) {
          const botToken = process.env.TELEGRAM_BOT_TOKEN || '7679093791:AAEljqJ8kDjE1m3dLgLq8dBcmi2qejpC5ww';
          const shiftTypeText = shiftData.shiftType === 'day' ? 'üåÖ –î–Ω–µ–≤–Ω–∞—è' : 'üåô –ù–æ—á–Ω–∞—è';
          const actionText = isUpdate ? '–∏–∑–º–µ–Ω–µ–Ω–∞' : '–Ω–∞–∑–Ω–∞—á–µ–Ω–∞';
          
          const message = `üé¨ CAMERA TOON - –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Å–º–µ–Ω–µ\n\n` +
                         `üë§ ${employee.name}\n` +
                         `üìÖ ${shiftData.date}\n` +
                         `‚è∞ ${shiftTypeText} —Å–º–µ–Ω–∞ ${actionText}\n\n` +
                         `‚úÖ –ù–∞–∑–Ω–∞—á–∏–ª: ${req.user.name}`;

          await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              chat_id: employee.telegramId,
              text: message,
              parse_mode: 'HTML',
            }),
          });
        }
      } catch (telegramError) {
        console.error('Telegram notification error:', telegramError);
        // Don't fail the shift creation if telegram fails
      }

      res.json(shift);
    } catch (error) {
      res.status(500).json({ message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
    }
  });

  app.delete('/api/shifts/:id', requireAuth, requireRole(['admin', 'worker']), async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const deleted = await storage.deleteShift(id);
      
      if (!deleted) {
        return res.status(404).json({ message: '–°–º–µ–Ω–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞' });
      }
      
      res.json({ message: '–°–º–µ–Ω–∞ —É–¥–∞–ª–µ–Ω–∞' });
    } catch (error) {
      res.status(500).json({ message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
    }
  });

  app.get('/api/shifts/today', requireAuth, async (req, res) => {
    try {
      const shifts = await storage.getTodayShifts();
      res.json(shifts);
    } catch (error) {
      res.status(500).json({ message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
    }
  });

  // Telegram routes
  app.post('/api/telegram/test', requireAuth, requireRole(['admin']), async (req, res) => {
    try {
      const { message } = req.body;
      const botToken = process.env.TELEGRAM_BOT_TOKEN || '7679093791:AAEljqJ8kDjE1m3dLgLq8dBcmi2qejpC5ww';
      
      // Test bot by sending message to admin
      const adminEmployee = await storage.getEmployee(req.user.id);
      if (!adminEmployee?.telegramId) {
        return res.status(400).json({ message: '–£ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω Telegram ID' });
      }

      const telegramMessage = message || '–¢–µ—Å—Ç –±–æ—Ç–∞ CAMERA TOON - —Å–≤—è–∑—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞!';
      
      // Send test message via Telegram API
      const telegramResponse = await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          chat_id: adminEmployee.telegramId,
          text: `üé¨ CAMERA TOON\n\n${telegramMessage}`,
          parse_mode: 'HTML',
        }),
      });

      if (!telegramResponse.ok) {
        const error = await telegramResponse.json();
        throw new Error(`Telegram API error: ${error.description}`);
      }

      res.json({ 
        message: '–¢–µ—Å—Ç –±–æ—Ç–∞ —É—Å–ø–µ—à–Ω–æ –≤—ã–ø–æ–ª–Ω–µ–Ω',
        details: '–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ Telegram'
      });
    } catch (error: any) {
      console.error('Telegram test error:', error);
      res.status(500).json({ 
        message: '–û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –±–æ—Ç–∞',
        error: error.message 
      });
    }
  });

  app.post('/api/telegram/broadcast', requireAuth, requireRole(['admin']), async (req, res) => {
    try {
      const { message } = req.body;
      const botToken = process.env.TELEGRAM_BOT_TOKEN || '7679093791:AAEljqJ8kDjE1m3dLgLq8dBcmi2qejpC5ww';
      
      if (!message) {
        return res.status(400).json({ message: '–°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º' });
      }

      // Get all employees with Telegram IDs
      const employees = await storage.getAllEmployees();
      const employeesWithTelegram = employees.filter(emp => emp.telegramId);

      if (employeesWithTelegram.length === 0) {
        return res.status(400).json({ message: '–ù–µ—Ç —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤ —Å –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω—ã–º Telegram' });
      }

      const results = [];
      
      for (const employee of employeesWithTelegram) {
        try {
          const telegramResponse = await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              chat_id: employee.telegramId,
              text: `üé¨ CAMERA TOON - –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ\n\n${message}\n\nüìÖ –û—Ç: ${req.user.name}`,
              parse_mode: 'HTML',
            }),
          });

          if (telegramResponse.ok) {
            results.push({ employee: employee.name, status: 'success' });
          } else {
            const error = await telegramResponse.json();
            results.push({ employee: employee.name, status: 'error', error: error.description });
          }
        } catch (error: any) {
          results.push({ employee: employee.name, status: 'error', error: error.message });
        }
      }

      const successCount = results.filter(r => r.status === 'success').length;
      
      res.json({ 
        message: `–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ ${successCount} –∏–∑ ${employeesWithTelegram.length} —Å–æ–æ–±—â–µ–Ω–∏–π`,
        results 
      });
    } catch (error: any) {
      console.error('Telegram broadcast error:', error);
      res.status(500).json({ 
        message: '–û—à–∏–±–∫–∞ —Ä–∞—Å—Å—ã–ª–∫–∏',
        error: error.message 
      });
    }
  });

  app.patch('/api/employees/guest/telegram', requireAuth, requireRole(['admin']), async (req, res) => {
    try {
      const { telegramId } = req.body;
      if (!telegramId) {
        return res.status(400).json({ message: 'Telegram ID –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' });
      }

      const employees = await storage.getAllEmployees();
      const guestEmployee = employees.find(emp => emp.role === 'guest');
      
      if (!guestEmployee) {
        return res.status(404).json({ message: '–ì–æ—Å—Ç–µ–≤–æ–π –∞–∫–∫–∞—É–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω' });
      }

      const updated = await storage.updateEmployee(guestEmployee.id, {
        telegramId: telegramId,
      });

      if (!updated) {
        return res.status(404).json({ message: '–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –≥–æ—Å—Ç–µ–≤–æ–π –∞–∫–∫–∞—É–Ω—Ç' });
      }

      res.json({ message: 'Telegram ID –≥–æ—Å—Ç—è —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω' });
    } catch (error) {
      res.status(500).json({ message: '–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è Telegram ID' });
    }
  });

  app.patch('/api/profile/update', requireAuth, async (req, res) => {
    try {
      const { name, color, frame, avatarUrl } = req.body;
      const userId = (req as any).user.id;

      const updated = await storage.updateEmployee(userId, {
        name,
        color,
        frame,
        avatarUrl,
      });

      if (!updated) {
        return res.status(404).json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' });
      }

      res.json({ message: '–ü—Ä–æ—Ñ–∏–ª—å —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω', user: updated });
    } catch (error) {
      res.status(500).json({ message: '–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è' });
    }
  });

  // Clean expired sessions periodically
  setInterval(async () => {
    await storage.cleanExpiredSessions();
  }, 60 * 60 * 1000); // Every hour

  const httpServer = createServer(app);
  return httpServer;
}
